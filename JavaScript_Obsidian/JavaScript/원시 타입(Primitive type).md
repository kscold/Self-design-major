- 자바 스크립트의 변수 타입에는 크게 Primitive type(원시타입)과 [[참조 타입(Reference Type)]]으로 나누어져 있다. 
- 원시 값이라고도 한다.

- 원시 타입(Primitive type)의 [[변수(Variable)]]들은 데이터 복사가 일어날 때 메모리 공간을 새로 확보하여 독립적인 값을 저장한다. 
- 원시 타입은 불변성(immutable)을 갖고있다.
- 따라서 [[불변성 유지]]가 된다.

- 원시값을 복사할 때 그 값은 또 다른 독립적인 메모리 공간에 할당하기 떄문에, 복사를 하고 수정해도 기존 원시값을 저장한 변수는 영향을 끼치지 않는다.
- 이처럼 실제 값을 복사하는 것을 깊은 복사라고 한다.

```js
const a = 'a';
let b = 'b';

b = 'c';

console.log(a); // 'a';
console.log(b); // 'c';
// 기존 값에 영향을 끼치지 않는다.
```


![[Pasted image 20240115030907.png]]

- 자바스크립트에서 원시 타입 (string, number, bigint, boolean, undefined, ES6 부터 추가된 symbol) 은 변수에 할당될 때, 메모리의 고정 크기로 원시 값을 저장하고 해당 저장된 값을 변수가 직접적으로 가리키는 형태를 띈다. 
- 또한 값이 절때 변하지않는 불변성을 갖고있기때문에 때문에 재할당 시 기존 값이 변하는것 처럼 보일지 몰라도 사실 새로운 메모리에 재할당한 값이 저장되고 변수가 가리키는 메모리가 달라졌을 뿐이다.


```jsx
let a = 100;
a = 50;
```

- a란 변수에 100이란 값을 할당하고 2번째 라인에서 50으로 재할당을 해준 예시이다. 
- 첫 라인이 실행되면 메모리에 Number타입의 100이란 값이 생성되고 식별자 a는 메모리에 생성된 100의 메모리 주소를 가리킨다.
- 그후 두번째 라인이 실행되면 이전에 메모리에 생성된 100이란 값이 50으로 수정되는것이 아닌, 새로운 Number타입의 50이란 값을 새로운 메모리에 생성하고 a가 가리키던 메모리가 바뀌는것이다.  

![](https://velog.velcdn.com/images%2Fnomadhash%2Fpost%2F5e197937-108e-4f9c-8be8-0c8c04d3fe8e%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202020-09-16%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%207.02.57.png)

- 즉 메모리에는 100과 50이란 값이 모두 존재하고 있으며, 앞에서 말했듯이 원시타입은 불변성을 갖고 있기 때문에 기존에 메모리에 생성된 값들은 그 자체가 변경될 수 없다. 
- 그저 식별자와 연결 되있는 메모리가 바뀌었기에 우리 눈에는 재할당 된 것처럼 보일뿐이다.

- 이를 고려하며 원시 타입의 값이 복사 될때는 어떤 일이 일어나는지 알아보자.

```jsx
let a = 100;
let b = a;
a = 50;

console.log(b) // 100
```

![](https://velog.velcdn.com/images%2Fnomadhash%2Fpost%2F4c48d687-2e50-42d0-a72a-28058f114cd1%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202020-09-18%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%204.01.34.png)

- 새로운 변수 b에 a를 할당 하게되면 변수 b의 공간에는 a의 값을 값을 통째로 복사하여 변수의 메모리에 담게 된다. 
- 그렇기에 변수 a가 50으로 재할당 되더라도 b는 전혀 영향을 받지 않는다.